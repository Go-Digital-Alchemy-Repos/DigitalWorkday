import { Router } from 'express';
import { requireSuperUser } from '../../../middleware/tenantContext';
import { storage } from '../../../storage';
import { db } from '../../../db';
import { invitations, users, workspaceMembers } from '@shared/schema';
import { eq } from 'drizzle-orm';
import { z } from 'zod';
import { hashPassword } from '../../../auth';
import { recordTenantAuditEvent } from '../../superAdmin';

export const superInvitationsRouter = Router();

superInvitationsRouter.post("/invitations/:invitationId/resend", requireSuperUser, async (req, res) => {
  try {
    const { invitationId } = req.params;
    const superUser = req.user as any;
    
    const [invitation] = await db.select()
      .from(invitations)
      .where(eq(invitations.id, invitationId))
      .limit(1);
    
    if (!invitation) {
      return res.status(404).json({ error: "Invitation not found" });
    }
    
    if (invitation.status !== "pending") {
      return res.status(400).json({ error: "Can only resend pending invitations" });
    }
    
    const crypto = await import("crypto");
    const token = crypto.randomBytes(32).toString("hex");
    const tokenHash = crypto.createHash("sha256").update(token).digest("hex");
    const expiresAt = new Date(Date.now() + 7 * 24 * 60 * 60 * 1000); // 7 days
    
    await db.update(invitations)
      .set({ tokenHash, expiresAt })
      .where(eq(invitations.id, invitationId));
    
    const baseUrl = process.env.BASE_URL || `${req.protocol}://${req.get("host")}`;
    const inviteUrl = `${baseUrl}/invite/${token}`;
    
    console.log(`[super/invitations/:id/resend] Invitation for ${invitation.email} (tenant: ${invitation.tenantId}) regenerated by super admin ${superUser?.email}`);
    
    res.json({ inviteUrl, message: "Invitation regenerated" });
  } catch (error) {
    console.error("[super/invitations/:id/resend] Error:", error);
    res.status(500).json({ error: "Failed to resend invitation" });
  }
});

superInvitationsRouter.delete("/invitations/:invitationId", requireSuperUser, async (req, res) => {
  try {
    const { invitationId } = req.params;
    const superUser = req.user as any;
    
    const [invitation] = await db.select()
      .from(invitations)
      .where(eq(invitations.id, invitationId))
      .limit(1);
    
    if (!invitation) {
      return res.status(404).json({ error: "Invitation not found" });
    }
    
    await db.delete(invitations).where(eq(invitations.id, invitationId));
    
    console.log(`[super/invitations/:id DELETE] Invitation for ${invitation.email} (tenant: ${invitation.tenantId}) deleted by super admin ${superUser?.email}`);
    
    res.json({ message: "Invitation deleted successfully" });
  } catch (error) {
    console.error("[super/invitations/:id DELETE] Error:", error);
    res.status(500).json({ error: "Failed to delete invitation" });
  }
});

superInvitationsRouter.post("/invitations/:invitationId/activate", requireSuperUser, async (req, res) => {
  try {
    const { invitationId } = req.params;
    const data = z.object({
      password: z.string().min(8, "Password must be at least 8 characters"),
      mustChangeOnNextLogin: z.boolean().default(true),
    }).parse(req.body);
    
    const [invitation] = await db.select()
      .from(invitations)
      .where(eq(invitations.id, invitationId))
      .limit(1);
    
    if (!invitation) {
      return res.status(404).json({ error: "Invitation not found" });
    }
    
    if (invitation.status !== "pending") {
      return res.status(400).json({ error: "Invitation is not pending" });
    }
    
    const existingUser = await storage.getUserByEmail(invitation.email);
    if (existingUser) {
      return res.status(409).json({ error: "A user with this email already exists" });
    }
    
    const passwordHash = await hashPassword(data.password);
    
    const [newUser] = await db.insert(users).values({
      email: invitation.email,
      firstName: invitation.firstName,
      lastName: invitation.lastName,
      name: `${invitation.firstName || ""} ${invitation.lastName || ""}`.trim() || invitation.email,
      passwordHash,
      role: invitation.role as any,
      tenantId: invitation.tenantId,
      isActive: true,
      mustChangePasswordOnNextLogin: data.mustChangeOnNextLogin,
    }).returning();
    
    if (invitation.workspaceId) {
      await db.insert(workspaceMembers).values({
        workspaceId: invitation.workspaceId,
        userId: newUser.id,
        role: invitation.role === "admin" ? "admin" : "member",
      }).onConflictDoNothing();
    }
    
    await db.update(invitations)
      .set({ status: "used", usedAt: new Date() })
      .where(eq(invitations.id, invitationId));
    
    const superUser = req.user as any;
    console.log(`[super/invitations/:id/activate] User ${newUser.email} (tenant: ${invitation.tenantId}) activated from invitation by super admin ${superUser?.email}`);
    
    res.json({ 
      user: newUser,
      message: "User activated successfully" 
    });
  } catch (error) {
    if (error instanceof z.ZodError) {
      return res.status(400).json({ error: "Validation error", details: error.errors });
    }
    console.error("[super/invitations/:id/activate] Error:", error);
    res.status(500).json({ error: "Failed to activate user" });
  }
});
