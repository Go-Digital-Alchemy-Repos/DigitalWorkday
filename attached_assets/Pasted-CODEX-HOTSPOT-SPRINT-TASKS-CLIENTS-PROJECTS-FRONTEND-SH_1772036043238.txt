CODEX HOTSPOT SPRINT (TASKS → CLIENTS → PROJECTS → FRONTEND SHAPING)
NON-DESTRUCTIVE • PERFORMANCE-FIRST • MEASURABLE • DOCUMENTED

You are working in the DigitalWorkday codebase (React frontend, Node/Express backend, PostgreSQL + Drizzle ORM).
Codex verdict: Tasks still #1 bottleneck due to N+1 relation hydration; Clients has N+1 expansion; Projects filters in memory; Frontend still pulls big arrays and shapes client-side; logging noise + invalidation storms remain.

GOAL: Fix the top bottlenecks with minimal risk:
1) Tasks: batched list hydration (kill N+1)
2) Clients: batch contacts/projects expansion (kill N+1)
3) Projects: push filter/sort/pagination into SQL (reduce payload + CPU)
4) Frontend: shift shaping to API contracts + reduce redundant fetches
5) Reduce noisy logging + control invalidation storms
6) Add endpoint-level profiling budgets + optional micro-caching

HARD RULES
- NON-DESTRUCTIVE: do not break existing endpoints or response shapes.
- Add new “v2 list” paths or “view=list” query params; keep old paths intact.
- Any behavior change must be behind feature flags:
  - ENABLE_TASKS_BATCH_HYDRATION
  - ENABLE_CLIENTS_BATCH_EXPANSION
  - ENABLE_PROJECTS_SQL_FILTERING
  - ENABLE_REPORT_ENDPOINT_PROFILING
  - ENABLE_HOTPATH_LOG_SAMPLING
  - ENABLE_LIST_LIGHT_PAYLOADS
- Keep detail endpoints unchanged; only list endpoints are optimized.
- Document everything in App Docs at end with before/after metrics.

============================================================
PHASE 0 — INSTRUMENTATION & BASELINE (DO FIRST)
============================================================
0.1 Add per-endpoint timing + query count instrumentation (dev/staging)
- Record: route, status, duration_ms, db_query_count, db_time_ms (if available), payload_bytes approx.
- Implement sampling in prod (1–5%) behind ENABLE_HOTPATH_LOG_SAMPLING.

0.2 Add endpoint “perf budgets” (soft enforcement)
- Create a simple JSON config mapping endpoint → p95 budget (ms)
- Expose a dev-only /internal/perf endpoint to view last N samples by route.
- DO NOT block startup; this is visibility only (CI gating later).

0.3 Baseline these endpoints:
- GET /api/tasks/my
- GET /api/clients (and any list endpoints)
- GET /projects (and includeCounts variant)
Capture p50/p95 and query counts BEFORE changes.

============================================================
PHASE 1 — TASKS: BATCHED LIST HYDRATION (TOP PRIORITY)
============================================================
Problem: /api/tasks/my uses storage.getTasksByUser which loops tasks and calls getTaskWithRelations per task, which fans out relation queries.

Solution: Introduce a batched hydration pipeline:
- fetch base tasks once
- fetch relations in bulk via IN(taskIds) (chunked)
- stitch in memory

1.1 Create a NEW service path (do not replace old yet)
server/src/services/tasks/taskListHydrator.ts

Export:
- getTasksForUserWithRelationsBatched({ tenantId, userId, filters, pagination, view })
- hydrateTasksRelations({ tenantId, taskIds, options })

1.2 Query strategy (SQL, Drizzle)
A) Base tasks query (paginated)
- Select minimal list fields by default (ENABLE_LIST_LIGHT_PAYLOADS):
  id, title, status, dueDate, priority, projectId, clientId, parentTaskId, createdAt, updatedAt, createdByUserId, visibility/isPrivate if exists, estimateHours if needed
- Apply server-side filters:
  status, search, projectId, clientId, due range, sort, limit, cursor
- Return: items + nextCursor

B) Relation batches by IN(taskIds) with chunking (e.g. 500)
- assignees by task_id
- watchers by task_id
- tags by task_id
- subtasks/children by parent_task_id (only for returned taskIds)
- section by section_id IN(...)
- project by project_id IN(...)
- client minimal stub by client_id IN(...) (if list needs it)
IMPORTANT: fetch only relations required for list view; full hydration only when requested.

1.3 Stitching
- Build maps keyed by taskId (and projectId, etc.)
- Compose final task DTOs in memory in ONE pass.

1.4 Integrate safely
- Update /api/tasks/my handler:
  IF ENABLE_TASKS_BATCH_HYDRATION:
    call new batched service
  ELSE:
    use existing storage.getTasksByUser path (unchanged)

- Do the same for project task loading that currently loops per task:
  add a batched “tasks for project list” hydration path.

1.5 Ensure counts/summaries do NOT loop tasks
- If you compute unread/overdue counts: use aggregated SQL queries scoped to user & tenant.

1.6 Validate
- Compare old vs new response shapes; keep additive-only changes.
- Ensure private visibility rules (if implemented) are enforced in base query.

============================================================
PHASE 2 — CLIENTS: REMOVE N+1 EXPANSION (SECOND PRIORITY)
============================================================
Problem: getClientsByWorkspace/getClientsByTenant fetch clients then loop per client for contacts + projects.

Solution: batch expansion:
- fetch clients (paginated + filters)
- fetch contacts for all clientIds IN(...)
- fetch projects for all clientIds IN(...)
- group in memory

2.1 Create NEW service path
server/src/services/clients/clientListExpander.ts
- getClientsListBatched({ tenantId/workspaceId, filters, pagination, view })
- expandClientsRelations({ clientIds, includeContacts, includeProjects })

2.2 Add “view=list” lightweight mode (ENABLE_LIST_LIGHT_PAYLOADS)
- list payload should not include full contacts/projects arrays by default
- Instead:
  - primaryContact stub or counts (contactsCount, projectsCount)
  - lastActivityAt (if cheap) or defer
- Full expansions fetched on client detail open.

2.3 Integrate safely
- Update list endpoints:
  IF ENABLE_CLIENTS_BATCH_EXPANSION:
    use batched expander
  ELSE:
    keep current loop implementation

2.4 Optimize last activity
- If lastActivityAt is expensive:
  - create a separate aggregated query for visible page only (clientIds IN visible set)
  - or omit from list view and lazy-fetch for a client drawer.
  - Keep behind flag.

============================================================
PHASE 3 — PROJECTS: SQL FILTERING + PAGINATION + LIGHT LIST PAYLOAD
============================================================
Problem: GET /projects loads broad sets then filters in JS; list payload too heavy.

Solution: new SQL-driven list endpoint behavior:
- WHERE clauses for status/client/team/search
- ORDER BY in SQL
- limit/cursor pagination
- lightweight list projection
- request project detail when opening project

3.1 Create NEW query builder
server/src/services/projects/projectListQuery.ts
- buildProjectsListQuery({ tenantId, filters, pagination, sort, view })

3.2 Endpoint changes (non-breaking)
- Add query params to existing /projects:
  status, clientId, teamId, search, sortBy, sortDir, limit, cursor, view=list
- If ENABLE_PROJECTS_SQL_FILTERING:
  use SQL query builder
  else fallback to existing in-memory filtering (unchanged)

3.3 Counts handling
- Keep your existing improvement for includeCounts=true (batched counts).
- Ensure counts are computed for the current page only, not for all projects.

============================================================
PHASE 4 — FRONTEND SHAPING: STOP PULLING HUGE ARRAYS
============================================================
Goal: shift filter/sort/search/pagination to API contracts. Reduce redundant list fetches.

4.1 My Tasks UI
- Update to request:
  /api/tasks/my?status=&search=&sort=&limit=&cursor=&view=list
- Remove client-side filter/sort transforms over full arrays:
  - keep UI transforms limited to local presentation only.
- Ensure pagination or infinite scroll.

4.2 Clients page: consolidate redundant mount fetches
Currently: /api/clients + hierarchy/summary/stage summary (duplicates work).
- Create ONE page-optimized endpoint (additive):
  GET /api/clients/page-data?view=list&include=summary,hierarchy,stageSummary
  OR
  GET /api/clients?view=list&includeSummaries=true
Return:
- paginated list items (light)
- summary blocks (counts by stage, etc.)
- hierarchy if required (or fetch lazily after initial paint)
Gate behind a feature flag:
  ENABLE_CLIENTS_PAGE_SINGLE_FETCH

4.3 Projects dashboard
- Same: /projects?view=list&... server-side shaping.
- Reduce client-side sort/filter on huge arrays.

4.4 React Query invalidations (reduce storms)
- Replace broad invalidations with targeted updates:
  - after project update: update project list cache item in place; invalidate only the relevant detail key
  - avoid invalidating both /api/v1/projects and /api/projects unless necessary
Add a small utility:
  updateListItemCache(queryKey, id, patch)

============================================================
PHASE 5 — REDUCE NOISY LOGGING ON HOT PATHS
============================================================
Problem: request logging on every /api/clients call can add I/O pressure.

5.1 Implement structured logger level gating + sampling:
- In prod:
  - info logs for errors and important events only
  - perf logs sampled (1–5%)
  - slow request logs only above threshold (e.g., >800ms) OR sampled
- In dev:
  - full logs allowed

5.2 Ensure logs are async-friendly and not JSON-stringifying huge objects.

Gate behind:
ENABLE_HOTPATH_LOG_SAMPLING

============================================================
PHASE 6 — ENDPOINT-LEVEL MICRO CACHING (SAFE, SHORT TTL)
============================================================
Add safe short TTL caches (per-process) for:
- /unread-count (2–5s)
- lightweight summaries (stage counts) (10–30s)
Rules:
- cache keys include tenantId + userId + relevant filters
- TTL short, correctness > performance
- bypass cache for authenticated changes when needed (optional)

Gate behind:
ENABLE_REPORT_ENDPOINT_PROFILING or separate ENABLE_SUMMARY_MICROCACHE

============================================================
PHASE 7 — DATABASE INDEX AUDIT (ONLY ADD MISSING)
============================================================
Ensure these exist (names vary; follow repo conventions):
Tasks:
- (tenant_id, assignee_id, status)
- (tenant_id, due_date, status)
- (tenant_id, project_id)
- (tenant_id, updated_at)
Relations:
- task_assignees(task_id, user_id)
- task_watchers(task_id, user_id)
- task_tags(task_id, tag_id)
- tasks(parent_task_id)
Clients:
- (tenant_id, status/stage)
Contacts:
- (tenant_id, client_id)
Projects:
- (tenant_id, status)
- (tenant_id, client_id)

Run EXPLAIN ANALYZE for:
- /api/tasks/my (new batched path)
- /api/clients list (batched expansion)
- /projects list (SQL filtering)

============================================================
PHASE 8 — FILE / ROUTE SEGMENTATION (MAINTAINABILITY + LOAD TIME)
============================================================
8.1 Split large route files into domain modules (no path changes):
- routes/tasks/*
- routes/clients/*
- routes/projects/*
- routes/reports/*
8.2 Split large service files into:
- list queries
- detail queries
- relation hydrators

Do not change import paths used by app; add re-export index files if needed.

============================================================
PHASE 9 — MEASURE BEFORE/AFTER + APP DOCS
============================================================
9.1 Record after metrics:
- p50/p95 duration
- DB query count
- payload sizes
Targets:
- /api/tasks/my: query count reduced from O(N) to <10–15 total queries
- /api/clients list: remove per-client loops; query count flat
- /projects list: avoid in-memory filtering; payload smaller

9.2 App Docs update:
Add:
- “Performance Sprint: Tasks/Clients/Projects”
- “List vs Detail Payload Standard”
- “Batched Hydration Pattern”
- “API Shaping Contract”
- “Logging + Sampling Policy”
- “Invalidation & Cache Hygiene”

============================================================
STOP CONDITION
============================================================
Stop when:
- Tasks list hydration no longer loops per task (batched & chunked)
- Clients list expansion no longer loops per client (batched & grouped)
- Projects list filtering/sort/pagination in SQL
- Frontend uses server-side shaping + reduced redundant fetches
- Logging noise reduced
- Before/after metrics captured
- Docs updated